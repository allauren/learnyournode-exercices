
 Promets-moi Que Ã‡a Ne Fera Pas Mal
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 Promesses multiples
 Exercice 11 sur 13


# Peut-on faire ce que fait Async.js ?

Lorsquâ€™on programme en asynchrone, on a souvent besoin dâ€™exÃ©cuter
plusieurs opÃ©rations en parallÃ¨le.  Dans certains cas, vous voudrez
mÃªme reporter les traitements suivants jusquâ€™Ã  ce quâ€™une liste
dâ€™opÃ©rations asynchrones soient toutes terminÃ©es.

Dans du code synchrone, ce serait trivial Ã  faire parce que les
opÃ©rations sont exÃ©cutÃ©es dans lâ€™ordre oÃ¹ elle sont Ã©crites :

    var thingOne = getThing(1);
    var thingTwo = getThing(2);
    
    combine(thingOne, thingTwo);

Nous aimerions crÃ©er une fonction qui nous permette de spÃ©cifier une liste
de valeurs asynchrones que nous aimerions rÃ©cupÃ©rer, et qui nous redonne
la main une fois quâ€™elles sont toutes disponibles.

    getAll([fetch(1), fetch(2)])
    .then(function (first, second) {
      console.log(first, second);
    });

## TÃ¢che

Ã‰crivons cette fonction !

CrÃ©ez une fonction all qui prend deux promesses en arguments.  Cette
fonction all devrait fonctionner comme suit :

  * CrÃ©er une promesse interne comme bon vous semble
  * CrÃ©er une variable `counter` initialisÃ©e Ã  zÃ©ro
  * Attacher des gestionnaires dâ€™accomplissement au deux promesses, et incrÃ©menter le compteur interne au sein de ces gestionnaires
  * Quand le compteur atteint 2, accomplir la promesse interne avec un tableau des **deux** valeurs accomplies
  * Pour finir, renvoyer la promesse interne

Quand vous aurez fini dâ€™Ã©crire all, passez-lui getPromise1() et
getPromise2(), et attachez un console.log comme gestionnaire
dâ€™accomplissement Ã  la promesse renvoyÃ©e.  Les deux fonctions
mentionnÃ©es seront mises Ã  votre disposition dans la portÃ©e globale.

## Conseils

Vous souhaiterez sans doute utiliser le bon vieux constructeur Promise ici.
Si vous trouvez une autre faÃ§on, nâ€™hÃ©sitez pas Ã  [nous le signaler](https://github.com/stevekane/promise-it-wont-hurt/issues) ;
je serais curieux de voir vos solutions !

MÃªme si cette leÃ§on est un bon exercice pratique, dans la vraie vie vous
utiliserez plutÃ´t Promise.all, dont nous rÃ©implÃ©mentons ici une version
rÃ©duire.  Promise.all prend un itÃ©rable (par exemple un tableau) de
promesses en argument unique, plutÃ´t que des arguments distincts.  Par
ailleurs, elle gÃ¨re les erreurs et transmet toute erreur interne en rejet
de la promesse renvoyÃ©e.

    Promise.all([getPromise1(), getPromise2()])
      .then(onFulfilled, onRejected);

Dans cette leÃ§on toutefois, nous avons pris soin de dÃ©sactiver cette
mÃ©thode utilitaire ğŸ˜ˆ


 Â» Pour rÃ©-afficher ces instructions, faites : promise-it-wont-hurt print
 Â» Pour exÃ©cuter votre programme dans un environnement de test, faites : promise-it-wont-hurt run program.js
 Â» Pour vÃ©rifier que votre programme rÃ©soud lâ€™exercice, faites : promise-it-wont-hurt verify program.js
 Â» Pour de lâ€™aide sur les commandes, faites : promise-it-wont-hurt help


